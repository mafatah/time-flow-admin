import { Test, TestingModule } from '@nestjs/testing';
import { ImageService } from '../src/common/image.service';
import * as fs from 'fs';
import * as path from 'path';

describe('ImageService', () => {
  let service: ImageService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [ImageService],
    }).compile();

    service = module.get<ImageService>(ImageService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('blurImage', () => {
    it('should blur an image buffer', async () => {
      // Create a simple test image buffer (1x1 pixel PNG)
      const testImageBuffer = Buffer.from([
        0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a,
        0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44, 0x52,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x08, 0x02, 0x00, 0x00, 0x00, 0x90, 0x77, 0x53,
        0xde, 0x00, 0x00, 0x00, 0x0c, 0x49, 0x44, 0x41,
        0x54, 0x08, 0xd7, 0x63, 0xf8, 0x0f, 0x00, 0x00,
        0x01, 0x00, 0x01, 0x5c, 0xc2, 0x8a, 0x8e, 0x00,
        0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae,
        0x42, 0x60, 0x82
      ]);

      const blurredBuffer = await service.blurImage(testImageBuffer, 5);
      
      expect(blurredBuffer).toBeInstanceOf(Buffer);
      expect(blurredBuffer.length).toBeGreaterThan(0);
      expect(blurredBuffer).not.toEqual(testImageBuffer);
    });

    it('should handle invalid image buffer', async () => {
      const invalidBuffer = Buffer.from('not an image');
      
      await expect(service.blurImage(invalidBuffer)).rejects.toThrow('Image processing failed');
    });
  });

  describe('getImageMetadata', () => {
    it('should extract metadata from image buffer', async () => {
      // Create a simple test image buffer (1x1 pixel PNG)
      const testImageBuffer = Buffer.from([
        0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a,
        0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44, 0x52,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x08, 0x02, 0x00, 0x00, 0x00, 0x90, 0x77, 0x53,
        0xde, 0x00, 0x00, 0x00, 0x0c, 0x49, 0x44, 0x41,
        0x54, 0x08, 0xd7, 0x63, 0xf8, 0x0f, 0x00, 0x00,
        0x01, 0x00, 0x01, 0x5c, 0xc2, 0x8a, 0x8e, 0x00,
        0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae,
        0x42, 0x60, 0x82
      ]);

      const metadata = await service.getImageMetadata(testImageBuffer);
      
      expect(metadata).toHaveProperty('width');
      expect(metadata).toHaveProperty('height');
      expect(metadata).toHaveProperty('format');
      expect(metadata).toHaveProperty('size');
      expect(metadata.width).toBe(1);
      expect(metadata.height).toBe(1);
      expect(metadata.format).toBe('png');
    });
  });

  describe('optimizeImage', () => {
    it('should optimize an image buffer', async () => {
      // Create a simple test image buffer (1x1 pixel PNG)
      const testImageBuffer = Buffer.from([
        0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a,
        0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44, 0x52,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x08, 0x02, 0x00, 0x00, 0x00, 0x90, 0x77, 0x53,
        0xde, 0x00, 0x00, 0x00, 0x0c, 0x49, 0x44, 0x41,
        0x54, 0x08, 0xd7, 0x63, 0xf8, 0x0f, 0x00, 0x00,
        0x01, 0x00, 0x01, 0x5c, 0xc2, 0x8a, 0x8e, 0x00,
        0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae,
        0x42, 0x60, 0x82
      ]);

      const optimizedBuffer = await service.optimizeImage(testImageBuffer);
      
      expect(optimizedBuffer).toBeInstanceOf(Buffer);
      expect(optimizedBuffer.length).toBeGreaterThan(0);
    });
  });
}); 